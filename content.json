{"meta":{"title":"10000's blog","subtitle":null,"description":"好少年光芒万丈","author":10000,"url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-08-11T07:40:53.831Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘の0x2710] 与&nbsp; 0x2710&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-07-23T02:18:07.825Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-08-19T02:14:40.562Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"本站使用的技术 本主题由 Hexo 驱动 主题为Hexo版本的主题Sakura🌸 本站由JSDelivr提供CDN加速 本博客托管于Github 个人服务器","keywords":"关于 Blog 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"let没有变量提升吗","slug":"let没有变量提升吗","date":"2020-08-25T01:05:15.000Z","updated":"2020-08-25T01:06:56.230Z","comments":true,"path":"2020/08/25/let没有变量提升吗/","link":"","permalink":"/2020/08/25/let没有变量提升吗/","excerpt":"","text":"","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"迭代器和生成器","slug":"迭代器和生成器","date":"2020-08-21T08:47:26.000Z","updated":"2020-08-25T02:49:50.992Z","comments":true,"path":"2020/08/21/迭代器和生成器/","link":"","permalink":"/2020/08/21/迭代器和生成器/","excerpt":"","text":"Symbol在介绍迭代器之前，有个绕不开的话题就是symbol 基本类型 基本类型（基本数值、基本数据类型）是一种既非对象也无方法的数据。在 JavaScript 中，共有7种基本类型：string，number，bigint，boolean，null，undefined，symbol (ECMAScript 2016新增)。 多数情况下，基本类型直接代表了最底层的语言实现。 所有基本类型的值都是不可改变的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变 以上摘自MDN原始数据 描述symbol 是ES6中新增的一种 原始数据类型 ，每个从Symbol()返回的symbol值都是唯一的，正因为这个特性，一个symbol值一般用来作为对象属性的标识符。Symbol类型唯一合理的用法是用变量存储 symbol的值，然后使用存储的值创建对象属性。 当一个 symbol 类型的值在属性赋值语句中被用作标识符，该属性（像这个 symbol 一样）是匿名的；并且是不可枚举的 这句话什么意思呢？ function symbolTest() { let key = Symbol(&quot;key&quot;); this.name = &quot;10000&quot;; this.age = 1; this[key] = function() { console.log(&quot;Symbol为标识符的函数&quot;); } this.test = function() { console.log(this[key]); console.log(this[key]()); } } let t = new symbolTest() for (const key in t) { if (t.hasOwnProperty(key)) { console.log(key); } } t.test() // 输出： name age test ƒ () { console.log(&quot;Symbol为标识符的函数&quot;); } Symbol为标识符的函数 上面这个例子可以看出 symbol 类型的值作为属性名时，该属性无法被for in 读取，且无法被外部访问，可以用来模拟私有属性，只能通过Object.getOwnPropertySymbols()遍历出symbol类型属性名或者使用Symbol.for(key) 获取symbol值 暴露给开发者的symbol 属性 描述 Symbol.iterator 一个返回一个对象默认迭代器的方法。被 for...of 使用。 Symbol.asyncIterator 一个返回对象默认的异步迭代器的方法。被 for await of 使用。 其他暴露给开发者的symbol请参考MDN Symbol 迭代器可迭代协议​ 可迭代协议允许 JavaScript 对象定义或定制它们的迭代行为 ​ 例如，在一个 for..of 结构中，哪些值可以被遍历到。 ​ 一些内置类型同时是内置可迭代对象，并且有默认的迭代行为 ​ 比如 Array 或者 Map，而其他内置类型则不是（比如 Object)）。 ​ 要成为可迭代对象， 一个对象必须实现 @@iterator 方法。 ​ 这意味着对象（或者它原型链上的某个对象）必须有一个键为 @@iterator 的属性 ​ 可通过常量 Symbol.iterator 访问该属性 [Symbol.iterator]描述： 一个无参数函数 ​ 返回一个符合迭代器协议的对象 迭代器协议​ 迭代器协议定义了产生一系列值（无论是有限个还是无限个）的标准方式。 ​ 当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。 ​ 只有实现了一个拥有以下语义（semantic）的 next() 方法，一个对象才能成为迭代器： 迭代器含有next方法并符合以下语义： 属性： next: 一个无参数函数，返回一个应当拥有以下两个属性的对象 done（boolean） 如果迭代器可以产生序列中的下一个值，则为 false。（这等价于没有指定 done 这个属性。） 如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。 value - 迭代器返回的任何 JavaScript 值。done 为 true 时可省略。 next() 方法必须返回一个对象，该对象应当有两个属性： done 和 value 如果返回了一个非对象值（比如 false 或 undefined），则会抛出一个 TypeError 异常（”iterator.next() returned a non-object value”）。 以上摘自迭代协议 由上文可知，要使对象可以被for of遍历必须要实现 @@iterator 方法，而它为symbol类型的值，可以通过公开的symbol： Symbol.iterator 来访问，因此可以结合迭代器协议来实现自定义对象的迭代 自定义迭代器并实现 @@iterator 方法let t = { name: &quot;0x2710&quot;, age: &quot;不告诉你&quot;, // 实现 @@iterator 方法 [Symbol.iterator]() { return myIterator } } // 自定义迭代器 let keys = Object.getOwnPropertyNames(t); let index = 0; let myIterator = { next: function () { if (index &lt; keys.length) { const res = { value: t[keys[index]], done: false } index++; return res; } else { return { value: undefined, done: true } } } } for (const v of t) { console.log(v); } // 输出： 0x2710 不告诉你 生成器生成器函数声明方式：function * 描述： ​ 这种声明方式(function关键字后跟一个星号）会定义一个生成器函数 (generator function) ​ 生成器函数在执行时能暂停，后面又能从暂停处继续执行。 ​ 调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 迭代器 （ iterator ）对象。 ​ 当这个迭代器的 next() 方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield的位置为止 ​ yield 后紧跟迭代器要返回的值。 ​ 或者如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。 ​ next()方法返回一个对象，这个对象包含两个属性：value 和 done，value 属性表示本次 yield 表达式的返回值，done 属性为布尔类型，表示生成器后续是否还有 yield 语句，即生成器函数是否已经执行完毕并返回。 ​ 调用 next()方法时，如果传入了参数，那么这个参数会传给上一条执行的 yield语句左边的变量 返回值 ：它返回一个 Generator 对象 yield描述： ​ yield关键字使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的return关键字。 ​ yield关键字实际返回一个IteratorResult对象，它有两个属性，value和done。value属性是对yield表达式求值的结果，而done是false，表示生成器函数尚未完全完成。 ​ 一旦遇到 yield 表达式，生成器的代码将被暂停运行，直到生成器的 next() 方法被调用。每次调用生成器的next()方法时，生成器都会恢复执行，直到达到以下某个值： yield，导致生成器再次暂停并返回生成器的新值。 下一次调用next()时，在yield之后紧接着的语句继续执行。 throw用于从生成器中抛出异常。这让生成器完全停止执行，并在调用者中继续执行，正如通常情况下抛出异常一样。 到达生成器函数的结尾；在这种情况下，生成器的执行结束，并且IteratorResult给调用者返回undefined并且done为true。 到达return 语句。在这种情况下，生成器的执行结束，并将IteratorResult返回给调用者，其值是由return语句指定的，并且done 为true。 如果将参数传递给生成器的next()方法，则该值将成为生成器当前yield操作返回的值。 以上摘自MDN yield 生成器​ 生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议 也就是说生成器函数返回的生成器可以作为迭代器使用 那么我们可以根据生成器的特性来定义一个通用的迭代器 使用生成器迭代对象// 使用生成器迭代对象 function* createIterator(obj) { let keys = Object.getOwnPropertyNames(obj); for (const key of keys) { yield obj[key]; } /** * ! 除了抛出异常以外，没有办法中止或跳出 forEach() 循环。 * ! 所以这里不能用forEach遍历 */ // keys.forEach(key =&gt; { // yield obj[key]; // 报错 // }); } let t = { name: &quot;0x2710&quot;, age: &quot;不告诉你&quot;, [Symbol.iterator]() { return createIterator(t); } } for (const v of t) { console.log(v); } // 输出： 0x2710 不告诉你","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"/tags/ES6/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"JS中new干了什么？","slug":"js中new干了什么","date":"2020-08-15T06:50:43.000Z","updated":"2020-08-25T02:48:51.182Z","comments":true,"path":"2020/08/15/js中new干了什么/","link":"","permalink":"/2020/08/15/js中new干了什么/","excerpt":"","text":"前言刚刚温习一遍闭包的时候看到了这种说法： function test1() { let n = 1; this.increase = function () { console.log(++n); } } function test2() { let n = 1; return { increase: function () { console.log(++n); } } } let t1 = new test1(); let t2 = test2(); 其中构造函数的创建方式可以理解为第二种函数调用的方式，只是其中有细微的差别 那和 new 的差别在哪呢？ new 干了啥？首先，我们在控制台输出t1和t2可以看到： test1 {increase: ƒ} increase: ƒ () __proto__: constructor: ƒ test1() __proto__: Object {increase: ƒ} increase: ƒ () __proto__: constructor: ƒ Object() ...... t1 的 __proto__ 指向的是他的构造函数的原型 而 t2 的 __proto__ 不是 那我们改改： function test2() { let n = 1; return { increase: function () { console.log(++n); }, __proto__: test2.prototype } } 这时候就差不多了 结论new 到底干了啥？ 创建对象 设置作用域链 为对象添加属性 返回对象 于是我们可以根据这个结论自定义一个 new 方法 let Create = function (functionName, ...args) { // 创建对象 let res = {}; // 设置作用域链 res.__proto__ = functionName.prototype; // 为对象添加属性 functionName.call(res, ...args); // 返回对象 return res; } function People(name, age) { this.name = name; this.age = age; } let _0x2710 = Create(People, &quot;0x2710&quot;, 18); console.log(_0x2710); let _10000 = new People(&quot;10000&quot;, 19); console.log(_10000); // _0x2710输出 People {name: &quot;0x2710&quot;, age: 18} age: 18 name: &quot;0x2710&quot; __proto__: constructor: ƒ People(name, age) __proto__: Object // _10000输出 People {name: &quot;10000&quot;, age: 19} age: 19 name: &quot;10000&quot; __proto__: constructor: ƒ People(name, age) __proto__: Object","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"VSCode修改默认HTML模板","slug":"VSCode修改默认HTML模板","date":"2020-08-14T08:23:37.000Z","updated":"2020-08-25T02:49:33.802Z","comments":true,"path":"2020/08/14/VSCode修改默认HTML模板/","link":"","permalink":"/2020/08/14/VSCode修改默认HTML模板/","excerpt":"","text":"前言最近创建html文件频率有点高，默认模板又不满意，虽然之前自定义了Vue的H5用户片段，但总归要使用默认模板，重新自定义用户片段又感觉浪费了自带的快捷键，习惯了Emmet，使用 ! + Tab 生成感觉也挺方便的，只是每次都要改语言什么的，很头疼，查了一些资料于是就有了这篇博客 1.找到默认模板位置1.1早期的模板位置看了几个百度的结果，模板位置都是在安装目录下的： resources\\app\\extensions\\emmet\\node_modules\\vscode-emmet-helper\\out\\expand\\expand-full.js 但是并没有 vscode-emmet-helper 取而代之的是 vscode-emmet-helper2 而且里面的目录结果也不太一样，看来是版本不一样，不过至少提供了思路，于是在此目录下搜索 expand-full.js 文件 1.2vscode-emmet-helper2 的模板位置经过尝试发现修改 vscode-emmet-helper2下的 lib\\cjs\\expand 目录中的 expand-full.js 是有效的 2.修改内容如果仅仅是修改默认语言 ​ 搜索 lang 定位到 defaultVariables 变量下的lang，注释并新开一行将值改为zh-CN即可 若想自定义模板内容 ​ 搜索 doc 定位到变量 html$1 下的doc ： &quot;doc&quot;: &quot;html[lang=${lang}]&gt;(head&gt;meta[charset=${charset}]+meta:vp+title{${1:Document}})+body&quot;, ，注释并新开一行修改即可，建议搜索修改其中的变量内容 保存并重启VSCode即可 提示从以上搜索结果的附近可看到如下内容： &quot;!!!&quot;: &quot;{&lt;!DOCTYPE html&gt;}&quot;, &quot;doc&quot;: &quot;html[lang=${lang}]&gt;(head&gt;meta[charset=${charset}]+meta:vp+title{${1:Document}})+body&quot;, &quot;!|html:5&quot;: &quot;!!!+doc&quot;, &quot;c&quot;: &quot;{&lt;!-- ${0} --&gt;}&quot;, 不难看出这是Emment的快捷键，可以借此机会了解一下Emment的快捷键:wink:","categories":[{"name":"教程","slug":"教程","permalink":"/categories/教程/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"/tags/vscode/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"/categories/教程/"}]},{"title":"字符串解构及扩展运算符展开字符串原理","slug":"字符串解构及扩展运算符展开字符串原理","date":"2020-08-07T14:22:12.000Z","updated":"2020-08-25T02:50:35.810Z","comments":true,"path":"2020/08/07/字符串解构及扩展运算符展开字符串原理/","link":"","permalink":"/2020/08/07/字符串解构及扩展运算符展开字符串原理/","excerpt":"","text":"前言朋友给我两行代码类似于下面： let [...arr] = &quot;123456&quot;; console.log(arr); 结果是输出一个数组 字符串也能解构？ 并且问了我 console.log(...&quot;123456&quot;); 将字符串变成了数组的原理是什么？ 听到第二个问题，感觉明显是错误的理解，于是，抱着打破砂锅问到底的精神去找了一下答案 字符串为什么能解构？MDN中说到： 通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。 也就是说解构有两种： 1.数组解构// 例一 let [a, b, c] = [1, 2, 3]; // 例二 let [...arr] = [1, 2, 3]; 例一是常规的数组解构，也可以像例二一样用剩余参数接收 2.对象解构// 例三 let t = {name:&quot;0x2710&quot;}; let {name} = t; console.log(name); // 0x2710 例三将在外部定义一个名字和对象内部一样的变量来接收对象解构的值 猜测与分析那么 [...arr] = &quot;123456&quot; 它是怎么解构字符串的呢？ 从格式上来说，是数组解构的格式，右边转换成了数组？ 显然不是 《JavaScript高级程序设计（第3版）》一书中 5.6 基本包装类型 说道 每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据 也就是说对字符串进行操作，操作过程中可以理解为将字符串转换为字符串对象 但是没有听说过会转换成数组的，而且解构中也完全没有此类说明，尽管字符串对象可以看成是伪数组 既然右边是对象那又是如何解构的呢？ 下面我们来看一个例子： let t = { name:&quot;0x2710&quot;, age: &quot;不告诉你&quot; } let [...arr] = t; console.log(arr); 结果报错：**Uncaught TypeError: t is not iterable** 什么意思呢，就是说t不可迭代 那我们自定义一个迭代器好了 let t = { name:&quot;0x2710&quot;, age: &quot;不告诉你&quot;, [Symbol.iterator]() { let keys = []; for(let v in t) { keys.push(v); } let index = 0; return{ next: function() { if(index &lt; keys.length) { const res = {value: t[keys[index]], done: false} index++; return res; } else { return {value: undefined, done: true} } } } } } let [...arr] = t; console.log(arr); 输出：**(2) [&quot;0x2710&quot;, &quot;不告诉你&quot;]** (自定义迭代器看这里：迭代器和生成器) 也就是说使用 [变量名] 方式解构，右边的对象必须是可迭代的 验证： let str = new String(&quot;123&quot;); let arr = [1, 2, 3] console.dir(str.__proto__); console.dir(arr.__proto__); // 展开 String 和 Array并在里面找到：Symbol(Symbol.iterator): ƒ [Symbol.iterator]() 也就是说数组和字符串对象都可以迭代 那使用 {} 解构数组会怎么样呢？ let {...arr} = [1, 2, 3]; console.log(arr); // 输出： {0: 1, 1: 2, 2: 3} 继续尝试解构自定义对象： let t = { name:&quot;0x2710&quot;, age: &quot;不告诉你&quot; } let {...arr} = t; console.log(arr); // 输出： {name: &quot;0x2710&quot;, age: &quot;不告诉你&quot;} 两种方式都能解构，这是为什么呢？ 实际上使用剩余参数接收解构对象是将对象枚举出来： let t = {}; Object.defineProperty(t, &quot;name&quot;, { value: &quot;0x2710&quot;, enumerable: false }); Object.defineProperty(t, &quot;age&quot;, { value: &quot;不告诉你&quot;, enumerable: false }); let {...arr} = t; console.log(arr); // 输出：{} 那指定参数名呢？ // 对象属性计算名和解构 let key = &quot;0&quot;; let { [key]: _0 } = [1, 2, 3]; console.log(_0); // 1 let t = { name:&quot;0x2710&quot;, age: &quot;不告诉你&quot; } let {name} = t; console.log(name); // 0x2710 let t = {}; Object.defineProperty(t, &quot;name&quot;, { value: &quot;0x2710&quot;, enumerable: false }); Object.defineProperty(t, &quot;age&quot;, { value: &quot;不告诉你&quot;, enumerable: false }); let {name} = t; console.log(name); // 0x2710 也就是说使用剩余参数接收( {...arr} ) 方式解构对象，右边的对象必须是可枚举的 指定属性名名则无限制 结论 解构数组，右边的对象必须是可迭代的 解构对象，若使用剩余参数接收，则右边的对象必须是可枚举的 解构对象，若指定属性名，则在对象中直接查找该属性 扩展运算符展开字符串原理扩展运算符为什么能展开字符串呢？ 看了上面字符串解构原理想必你心理已经有个答案了，但是呢我们还是来验证一下 MDN展开语法说道： 展开语法(Spread syntax), 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。(译者注: 字面量一般指 [1, 2, 3] 或者 {name: &quot;mdn&quot;} 这种简洁的构造方式) 展开数组：let arr = [1, 2, 3] console.log(...arr); // 1 2 3 展开字符串：console.log(...&quot;123&quot;); // 1 2 3 同样，我认为这里只转换成字符串对象 展开自定义对象：let t = { name:&quot;0x2710&quot;, age: &quot;不告诉你&quot; } console.log(...t); // Uncaught TypeError: Found non-callable @@iterator Found non-callable @@iterator ：发现不可调用的 @@iterator @@iterator是个什么东西呢？MDN又说道： [@@iterator]() 方法返回一个新的Iterator对象 换句话说，也是没有迭代器，那我们把上面的迭代器搬过来好了： let t = { name:&quot;0x2710&quot;, age: &quot;不告诉你&quot;, [Symbol.iterator]() { let keys = []; for(let v in t) { keys.push(v); } let index = 0; return{ next: function() { if(index &lt; keys.length) { const res = {value: t[keys[index]], done: false} index++; return res; } else { return {value: undefined, done: true} } } } } } console.log(...t); // 0x2710 不告诉你 结论扩展运算符展开字符串，字符串先隐式转换成字符串对象，再进行迭代转换成 值1, 值2, 值3 这种形式","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"/tags/ES6/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"npm加速及设置全局安装位置","slug":"npm加速及设置全局安装位置","date":"2020-08-06T01:11:50.000Z","updated":"2020-08-25T02:49:04.495Z","comments":true,"path":"2020/08/06/npm加速及设置全局安装位置/","link":"","permalink":"/2020/08/06/npm加速及设置全局安装位置/","excerpt":"","text":"1.NPM加速使用 npm config ls 来查看当前配置 可以看到 metrics-registry = &quot;https://registry.npmjs.org/&quot; 也就是npm默认源地址 如果你在国内，使用此源可能比较慢 永久更改npm源可以使用 npm set registry 源地址 来永久更改npm源 这里我们使用淘宝镜像 即：npm config set registry https://registry.npm.taobao.org 临时使用国内源可使用 --registry=原地址 来临时使用新的源地址，如：npm install cnpm -g --registry=http://registry.npm.taobao.org 会从淘宝镜像下载安装cnpm 但是每次都要输入比较麻烦，建议永久更改为国内源 2.更改NPM全局安装位置及缓存位置更改位置同样使用 npm config ls 来查看当前配置 或者 使用 npm get prefix 查看全局安装位置 使用 npm get cache 查看缓存位置 可以看到： 默认全局安装位置：C:\\Users\\用户名\\AppData\\Roaming\\npm 默认缓存位置： C:\\Users\\用户名\\AppData\\Roaming\\npm-cache 更改位置： 使用 npm set prefix 全局安装文件夹 改全局安装位置 使用 npm set cache 缓存文件夹 来更改缓存位置 更改环境变量添加NODE_PATH为了能在项目中直接导入全局安装的包务必按照以下方法添加环境变量： 此电脑(我的电脑) –&gt; 右键 –&gt; 属性 左侧找到高级系统设置 下方环境变量 在系统变量中点击新建，填入变量名NODE_PATH 变量值为 你的npm全局安装位置\\node_modules 保存之后重启你的编译器就可以导入全局安装的包了 添加npm环境变量此电脑(我的电脑) –&gt; 右键 –&gt; 属性 左侧找到高级系统设置 下方环境变量 系统变量 ​ 新建 ​ 变量名：NPM_PREFIX ​ 变量值： 你的npm全局安装路径 如 D:\\Develop\\nodejs\\npm_global ​ 更改Path ​ win7用户在后面追加 ;%NPM_PREFIX% ​ win10用户直接新建写入 %NPM_PREFIX% 用户变量 ​ 如果发现Path中有安装时自动添加的之前的npm路径，可选择直接删除或者参照系统变量设置值 点击确定保存即可","categories":[{"name":"教程","slug":"教程","permalink":"/categories/教程/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"/tags/npm/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"/categories/教程/"}]},{"title":"VSCode 自定义代码片段","slug":"VSCode 自定义代码片段","date":"2020-08-01T01:45:16.000Z","updated":"2020-08-25T02:49:20.443Z","comments":true,"path":"2020/08/01/VSCode 自定义代码片段/","link":"","permalink":"/2020/08/01/VSCode 自定义代码片段/","excerpt":"","text":"1.打开.json文件​ 文件(File)→首选项(Perferences)→用户片段(User Snippets) ​ 这里使用的是html 所以以自定义html代码片段为例，其他语言改成相应的json文件即可 ​ 在弹出的搜索框输入 html 打开html.json 2.自定义代码片段​ 这里以自定义Vue模板为例 ​ 打开html.json后在大括号中填入： &quot;h5 模板&quot;: { // 模板名 &quot;prefix&quot;: &quot;vh&quot;, // 快捷键 &quot;body&quot;: [ // Document 内容 &quot;&lt;!DOCTYPE html&gt;&quot;, &quot;&lt;html lang=\\&quot;zh-CN\\&quot;&gt;&quot;, &quot;&lt;head&gt;&quot;, &quot;\\t&lt;meta charset=\\&quot;UTF-8\\&quot;&gt;&quot;, &quot;\\t&lt;meta name=\\&quot;viewport\\&quot; content=\\&quot;width=device-width, initial-scale=1.0\\&quot;&gt;&quot;, &quot;\\t&lt;title&gt;Document&lt;/title&gt;&quot;, &quot;\\t&lt;script src=\\&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js\\&quot;&gt;&lt;/script&gt;&quot;, &quot;&lt;/head&gt;&quot;, &quot;&lt;body&gt;&quot;, &quot;\\t&lt;div id =\\&quot;app\\&quot;&gt;$1&lt;/div&gt;\\n&quot;, &quot;\\t&lt;script&gt;&quot;, &quot;\\t//创建Vue实例,得到 ViewModel&quot;, &quot;\\tvar vm = new Vue({&quot;, &quot;\\t\\tel: &#39;#app&#39;,&quot;, &quot;\\t\\tdata: {},&quot;, &quot;\\t\\tmethods: {}&quot;, &quot;\\t});&quot;, &quot;\\t&lt;/script&gt;&quot;, &quot;&lt;/body&gt;&quot;, &quot;&lt;/html&gt;&quot; ], &quot;description&quot;: &quot;vue html5 模板&quot; // 描述 } 注意：自定义时注意转义字符 3.使用方法​ 创建html文件后，输入快捷，键按Tab或 Enter 即可 4.Snippet语法制表位(Tabstops)使用制表位可在代码片段中使用 Tab 键移动光标位置，使用$number如$1, $2 等代指光标位置，其中后面的数字表示光标的移动顺序，$0表示光标的最终位置，如果代码片段中有多个相同的制表位(如两个$1) 则编译器会同时出现多个光标 占位符(Placeholders)占位符是带默认值的制表位，占位符中的文本会被插入到制表位中，并全选以方便修改 例：&lt;div id=&#39;${1:app}&#39;&gt;&lt;/div&gt; 选择项(Choice)占位符可以有多个选择项，默认使用第一个，输入时弹出选择项可供用户选择，选项的开始和结束使用 | 符号，其中选择项使用 , 分隔，如：${1|one,two,three|} 以上是Snippet部分语法 参考自 vscode 自定义代码片段","categories":[{"name":"教程","slug":"教程","permalink":"/categories/教程/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"/tags/vscode/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"/categories/教程/"}]},{"title":"盒子模型宽度计算规则","slug":"盒子模型宽度计算规则","date":"2020-07-27T03:57:37.000Z","updated":"2020-08-25T02:50:07.665Z","comments":true,"path":"2020/07/27/盒子模型宽度计算规则/","link":"","permalink":"/2020/07/27/盒子模型宽度计算规则/","excerpt":"","text":"前言这几天在学习负边距的时候发现一个问题： 当div(其父元素宽高为200px，未设置其他属性)宽度auto的时候，设置margin-left为负100px时，浏览器控制台中的盒子模型中with(内容宽度)变为300px，效果如下： HTML和css如下： &lt;div id=&quot;test1&quot;&gt; &lt;div id=&quot;test2&quot;&gt;&lt;/div&gt; &lt;/div&gt; #test1 { width: 200px; height: 200px; background: burlywood; } #test2 { width: auto; margin-left: -100px; } 这与盒子模型的计算规则有关，下面将详细说一下盒子模型的计算规则 以下内容均以标准盒子模型为准 在了解计算规则之前，先了解两个名词概念 计算值和使用值计算值 计算值指的是属性中所定义的值，如width：100px这个值即计算值 使用值 使用值简单说就是用于渲染的值,大部分情况下使用值和计算值相同 详细描述见6.1 Specified, computed, and actual values 行内非替换元素css规范中，行内非替换元素的宽度计算有如下说明： The ‘width’ property does not apply. A computed value of ‘auto’ for ‘margin-left’ or ‘margin-right’ becomes a used value of ‘0’. 谷歌翻译为： ​ 在“宽度”属性不适用。“左边距”或“右边距 ”的“自动”计算值变为使用值“ 0”。 即： 宽度不适用，行内非替换元素的宽度由内容决定 margin-left/margin-right 计算值为 auto 时 使用值为 0 行内替换元素 margin-left/margin-right 计算值为 auto 时 使用值为0 width和height计算值都为 auto 并且元素具有固有宽度，width 值为固有宽度的值 width和height计算值都为 auto 且元素没有固有宽度，但有固有高度或者指定高度且有固有比例，此时width的使用值为：高度使用值*比例 width和height计算值都为auto 并且元素具有固有比率，若该元素没有固有宽高，则则CSS 2.2中未定义’width’的使用值，CSS2.2中建议如果元素的宽度本身不取决于替换元素的宽度，则 width 的使用值是根据文档流中块级非替换元素的公式计算得出的 width的计算值为 auto ，并且元素具有固有宽度，则该固有宽度就是 width 的使用值 width 的计算值为 auto 但不满足上述任何条件，则宽度的使用值则为300px，若300px太宽无法被设备容纳，则使用宽高比为2:1的矩形宽度来代替(此处机翻可能有误，暂未验证) 块级非替换元素计算公式margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 包含块(containing block)宽度 如果border-left、padding-left、width、border-right、padding-right均不为auto，且margin-left和left有非auto计算值，则被称为过度约束， 如果direction(文本排列方向)为ltr,则margin-right属性值将被忽略，且该属性的使用值为使计算公式成立的值，如果direction(文本排列方向)为rtl则margin-left被忽略使用值同上 如果将width计算值为auto，则其他所有auto使用值将变为0，且width = 包含块宽度(此时内容宽度为100%) - 当前所有指定值的和 当width不为auto，且margin-left和margin-right都是auto时，它们的应用值相等。此时，该元素相对于包含块边界水平居中。 其中第2条：当 width 计算值为 auto 时 width = 包含块宽度 - 负边距即width的使用值增加，即为上述问题的答案 其中第3条是块级元素通过 margin：0 auto 水平居中的原理 注意：margin默认值为0，所以需要手动设置auto 未完待续……","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"拉取github项目到本地进行开发","slug":"拉取github项目到本地进行开发","date":"2020-07-26T14:11:16.000Z","updated":"2020-08-25T02:50:24.059Z","comments":true,"path":"2020/07/26/拉取github项目到本地进行开发/","link":"","permalink":"/2020/07/26/拉取github项目到本地进行开发/","excerpt":"","text":"前言本教程建立在你已经安装git并完成添加Github公匙 配置当你想在一个新文件夹中拉取github仓库中的代码并进行同步开发时可参照本教程 1.初始化本地仓库使用 git init 命令初始化一个空的本地仓库 2.关联远程仓库使用 git remote add [shortname] [url] 来关联远程仓库 如 git remote add origin &#x67;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#111;&#109;:0x2710-10000/Pages.git 其中 shortname用来指其后的仓库地址的简称 url 可以支持3种类型：(此处示例摘自菜鸟教程笔记) git@github.com:fsliurujie/test.git --SSH协议 git://github.com/fsliurujie/test.git --GIT协议 https://github.com/fsliurujie/test.git --HTTPS协议 这里我们添加了公匙选所以择ssh协议地址可以不用输入密码 3.拉取仓库对应分支的更新使用 git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 来拉取更新 如 git pull origin master:master 如果远程分支master要与当前分支合并，则冒号后面可以省略,简写为: git pull origin master 如果当前分支与远程分支存在追踪关系，就可以省略远程分支名: git pull origin 如果当前分支只有一个追踪分支，远程主机名也可以省略： git pull 所以这里如果仓库就只有一个分支使用 git pull 即可 若有多个分支，使用 git pull &lt;远程主机名&gt; &lt;远程分支名&gt; 即可","categories":[{"name":"教程","slug":"教程","permalink":"/categories/教程/"}],"tags":[{"name":"Git","slug":"Git","permalink":"/tags/Git/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"/categories/教程/"}]},{"title":"Display inline, inline-block, block 的区别","slug":"display inline inlineblock block 的区别","date":"2020-07-22T10:47:50.000Z","updated":"2020-08-25T02:48:18.610Z","comments":true,"path":"2020/07/22/display inline inlineblock block 的区别/","link":"","permalink":"/2020/07/22/display inline inlineblock block 的区别/","excerpt":"","text":"前言前端时间学习Vue的时候写了个轮播图，期间偶然发现display block和inline-block元素高度竟然不一样Σ( ° △ °|||)︴ 于是在搜索引擎上一顿查找，终于找到了答案 这里呢，准备顺带说一下另外两个属性 inline元素 inlineThe element generates one or more inline element boxes that do not generate line breaks before or after themselves. In normal flow, the next element will be on the same line if there is space 上面引用自 MDN web docs display 翻译过来： 元素会生成一个或多个内联元素框，这些框不会在自身之前或之后产生换行符。在文档流中，如果有空间，则下一个元素将和这个元素在同一行上 当你在vscode中给一个block元素设置宽高属性之后再写上display:inline; 会发现编译器发出如下警告： 上面是width属性的解释可以忽略 下面翻译过来是： 由于display，该属性被忽略。 使用&#39;display：inline&#39;，width，height，margin-top，margin-bottom和float属性无效 总结 inline 元素特点： 元素显示为行内元素，空间足够时，多个inline元素将在同一行 width、height、margin-top、margin-bottom和float属性无效 注意行高和padding等属性有效 宽高由内容决定 block元素 blockThe element generates a block element box, generating line breaks both before and after the element when in the normal flow. 引用自 MDN web docs display 翻译过来： 该元素生成一个块元素框，在正常流中时在元素之前和之后都产生换行符。 总结 block 元素特点： 元素前后产生换行，即元素独占一行 默认宽度是100% 宽高边距等均有效 inline-block元素英语太差没在官网找到解释，这里贴一段百度到的解释(不保证语义完全正确) inline-block将对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行内 即inline-block具备inline和block两种特点 元素可在同一行显示 元素的宽高等可调 inline-block和block对齐下面回到最开始的问题 这里为了方便大家理解引用 CSDN博主水荷的博客inline-block对齐，设置inline-block元素内容不同位置相互影响原因中的示例 对两个并列元素设置了display: inline-block;以为他们的位置是这个样子结果确是这个样子：我们来看一下这个div的界限发现，左边图片贴在div的顶部，右边气泡并没有贴着div的顶部，解决方法：给两个inline-block元素加上以下属性： vertical-align:top; 问题解决了 原因是inline-block元素将对象呈递为内联对象 也就是说inline-block的对齐方式将使用inline的对齐方式(baseline对齐) 引用原博客的结论： 对于一个inline-block元素，如果内部没有inline内联元素，或者overflow不是visible，则该元素的基线就是它margin的底边缘，否则就是元素内部最后一行内联元素的基线。对此我们有多种解决办法：1、暴力float，当然这是备选方案，毕竟脱离文档流后页面元素会不好控制2、简单粗暴地给所有元素都加上内容，例如空格符3、设置所有内联元素 vertical-align: top/middle/bottom; 属性，改变默认设置。","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"GitHub Pages 自定义域名","slug":"GithubPages自定义域名","date":"2020-07-21T08:52:36.000Z","updated":"2020-08-25T02:48:37.381Z","comments":true,"path":"2020/07/21/GithubPages自定义域名/","link":"","permalink":"/2020/07/21/GithubPages自定义域名/","excerpt":"","text":"购买域名​ 在腾讯云、阿里云、华为云等域名提供商购买域名 ​ 这里以腾讯云为例 解析​ 1.进入域名解析控制台(各大平台的入口不一，详情参见域名提供商的帮助文档) ​ 2.添加记录 记录类型 主机记录 记录值 CNAME blog 你的github用户名.github.io 记录类型：CNAME​ 将一个域名指向另一个域名，并由另一个域名提供IP地址 主机记录若你购买的域名为 example.com 主机记录设置为bolg则你的博客地址为bolg.example.com 可以根据自己的喜好更改此地址 记录值​ 指向的域名，即你的Github Pages地址的域名，格式为你的github用户名.github.io(不要加https://哦) Github 配置​ 进入Github你托管的博客项目，点击setting ​ 在Github Pages中找到Custom domain并输入上述设置的域名(如blog.example.com)并保存 hexo配置​ 如果你使用的是hexo，会发现每次部署的时候github的配置都不生效，因为Github配置实际上是在项目目录下生成一个名为 CNAME 的文件，但你本地目录并没有这个文件，所以在你本地博客的source目录下新建一个名为 CNAME 的文件，文件内容为你的域名然后保存","categories":[{"name":"教程","slug":"教程","permalink":"/categories/教程/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"/categories/教程/"}]}]}